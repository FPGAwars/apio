# -*- coding: utf-8 -*-
# -- This file is part of the Apio project
# -- (C) 2016-2024 FPGAwars
# -- Authors
# --  * JesÃºs Arroyo (2016-2019)
# --  * Juan Gonzalez (obijuan) (2019-2024)
# -- License GPLv2
"""Implementation of 'apio api' command"""

import sys
import json
from typing import Optional
from pathlib import Path
from glob import glob
import click
import usb.core
import usb.backend.libusb1
from apio.managers import installer
from apio.commands import options
from apio.common.apio_console import cout, cerror
from apio.common.apio_styles import INFO
from apio.utils import cmd_util
from apio.apio_context import ApioContext, ApioContextScope
from apio.utils.cmd_util import ApioGroup, ApioSubgroup, ApioCommand


# ------ apio api test

# TODO: Delete this command once the testing is done.

# -- Text in the rich-text format of the python rich library.
APIO_API_LAB_HELP = """
The command 'apio api test' is a temporary command that is used \
for cross platform testing by the apio team.
"""


def get_usb_str(device: usb.core.Device, index: int) -> Optional[str]:
    """Extract usb string by its index."""
    # pylint: disable=broad-exception-caught
    try:
        return usb.util.get_string(device, index)
    #   print(f"{serial_number=}")
    except Exception as e:
        _ = e
        return "(exception)"


@click.command(
    name="test",
    cls=ApioCommand,
    short_help="Temporary experimental internal testing.",
    help=APIO_API_LAB_HELP,
)
def _test_cli():
    """Implements the 'apio apio test' command."""

    apio_ctx = ApioContext(scope=ApioContextScope.NO_PROJECT)
    cout(f"Platform id: {apio_ctx.platform_id}")

    # -- Prepare the packages for use.
    installer.install_missing_packages_on_the_fly(apio_ctx)
    # pkg_util.set_env_for_packages(apio_ctx, quiet=not verbose)

    def find_library(name: str):
        print(f"{name=}")
        oss_dir = apio_ctx.get_package_dir("oss-cad-suite")
        print(f"{oss_dir=}")
        pattern = oss_dir / "lib" / f"lib{name}*"
        print(f"{pattern=}")
        files = glob(str(pattern))
        print(f"{files=}")
        assert len(files) <= 1
        if files:
            return files[0]
        return None

    backend = usb.backend.libusb1.get_backend(find_library=find_library)
    # backend = usb.backend.libusb1.get_backend()

    # find USB devices
    devices = usb.core.find(find_all=True, backend=backend)
    # loop through devices, printing vendor and product ids in decimal and hex
    for i, device in enumerate(devices):
        print()
        print(f"========= Device [{i}] ===========")
        print()
        assert isinstance(device, usb.core.Device), type(device)

        print(f"id:           {device.idVendor:04X}:{device.idProduct:04x}")
        print(f"bus:dev:      {device.bus}:{device.address}")
        print(f"manufacturer: {get_usb_str(device, device.iManufacturer)}")
        print(f"product:      {get_usb_str(device, device.iProduct)}")
        print(f"Serial:       {get_usb_str(device, device.iSerialNumber)}")

        print()
        print(device)
        print()


# ------ apio api info

# -- Text in the rich-text format of the python rich library.
APIO_API_INFO_HELP = """
The command 'apio api info' exports apio information as a JSON document.

The optional flag '--timestamp' allows the caller to embed in the JSON \
document a known timestamp that allows to verify that the JSON document \
was indeed was generated by the same invocation.

Examples:[code]
  apio api info                # Write to stdout
  apio api info  -o apio.json  # Write to a file[/code]

Currently, the JSON document includes a list of supported boards and various
information about them. Additional information can be added as needed.
"""


timestamp_option = click.option(
    "timestamp",  # Var name.
    "-t",
    "--timestamp",
    type=str,
    metavar="text",
    help="Set a user provided timestamp.",
    cls=cmd_util.ApioOption,
)

output_option = click.option(
    "output",  # Var name.
    "-o",
    "--output",
    type=str,
    metavar="file-name",
    help="Set output file.",
    cls=cmd_util.ApioOption,
)


@click.command(
    name="info",
    cls=ApioCommand,
    short_help="Retrieve apio information.",
    help=APIO_API_INFO_HELP,
)
@timestamp_option
@output_option
@options.force_option_gen(help="Overwrite output file.")
def _info_cli(
    # Options
    timestamp: str,
    output: str,
    force: bool,
):
    """Implements the 'apio apio info' command."""

    # pylint: disable=too-many-locals

    # -- For now, the information is not in a project context. That may
    # -- change in the future.
    apio_ctx = ApioContext(scope=ApioContextScope.NO_PROJECT)

    # -- The top dict that we will emit as json.
    top_dict = {}

    # -- Append user timestamp if specified.
    if timestamp:
        top_dict["timestamp"] = timestamp

    # -- Generate the 'boards' section.
    boards_section = {}
    for board_id, board_info in apio_ctx.boards.items():
        # -- The board output dict.
        new_board = {}

        # -- Add board description
        new_board["description"] = board_info.get("description", None)

        # -- Add board's fpga information.
        new_fpga = {}
        fpga_id = board_info.get("fpga", None)
        fpga_info = apio_ctx.fpgas.get(fpga_id, {})
        new_fpga["id"] = fpga_id
        new_fpga["part-num"] = fpga_info.get("part_num", None)
        new_fpga["arch"] = fpga_info.get("arch", None)
        new_board["fpga"] = new_fpga

        # -- Add board's programmer information.
        new_programmer = {}
        programmer_id = board_info.get("programmer", {}).get("type", None)
        new_programmer["id"] = programmer_id
        new_board["programmer"] = new_programmer

        # -- Add the board to the boards dict.
        boards_section[board_id] = new_board

    # -- Add the boards section to the top dict.
    top_dict["boards"] = boards_section

    # -- Format the top dict as json text.
    text = json.dumps(top_dict, indent=2)

    if output:
        # -- Output the json text to a user specified file.
        output_path = Path(output)

        if output_path.is_dir():
            cerror(f"The output path {output_path} is a directory.")
            sys.exit(1)

        if output_path.exists() and not force:
            cerror(f"The file already exists {output_path}.")
            cout("Use the --force option to allow overwriting.", style=INFO)
            sys.exit(1)

        with open(output, "w", encoding="utf-8") as f:
            f.write(text)
    else:
        # -- Output the json text to stdout.
        print(text, file=sys.stdout)


# ------ apio apio

# -- Text in the rich-text format of the python rich library.
APIO_API_HELP = """
The command group 'apio apio' contains subcommands that that are intended \
to be used by tools and programs such as icestudio, rather than being used \
directly by users.
"""

# -- We have only a single group with the title 'Subcommands'.
SUBGROUPS = [
    ApioSubgroup(
        "Subcommands",
        [
            _info_cli,
            _test_cli,
        ],
    )
]


@click.command(
    name="api",
    cls=ApioGroup,
    subgroups=SUBGROUPS,
    short_help="Apio programmatic interface.",
    help=APIO_API_HELP,
)
def cli():
    """Implements the 'apio apio' command group."""

    # pass
