# -*- coding: utf-8 -*-
# -- This file is part of the Apio project
# -- (C) 2016-2024 FPGAwars
# -- Authors
# --  * Jes√∫s Arroyo (2016-2019)
# --  * Juan Gonzalez (obijuan) (2019-2024)
# -- License GPLv2
"""Implementation of 'apio api' command"""

import sys
from typing import Dict, List
import json
from pathlib import Path
import click
from apio.commands import options
from apio.managers import installer
from apio.common.apio_console import cout, cerror
from apio.common.apio_styles import INFO
from apio.utils import cmd_util, usb_util, serial_util
from apio.utils.usb_util import UsbDevice
from apio.utils.serial_util import SerialDevice
from apio.apio_context import ApioContext, ApioContextScope
from apio.utils.cmd_util import ApioGroup, ApioSubgroup, ApioCommand


timestamp_option = click.option(
    "timestamp",  # Var name.
    "-t",
    "--timestamp",
    type=str,
    metavar="text",
    help="Set a user provided timestamp.",
    cls=cmd_util.ApioOption,
)

output_option = click.option(
    "output",  # Var name.
    "-o",
    "--output",
    type=str,
    metavar="file-name",
    help="Set output file.",
    cls=cmd_util.ApioOption,
)


def write_as_json_doc(top_dict: Dict, output_flag: str, force_flag: bool):
    """A common function to write a dict as a JSON doc."""
    # -- Format the top dict as json text.
    text = json.dumps(top_dict, indent=2)

    if output_flag:
        # -- Output the json text to a user specified file.
        output_path = Path(output_flag)

        if output_path.is_dir():
            cerror(f"The output path {output_path} is a directory.")
            sys.exit(1)

        if output_path.exists() and not force_flag:
            cerror(f"The file already exists {output_path}.")
            cout("Use the --force option to allow overwriting.", style=INFO)
            sys.exit(1)

        with open(output_flag, "w", encoding="utf-8") as f:
            f.write(text)
    else:
        # -- Output the json text to stdout.
        print(text, file=sys.stdout)


# ------ apio api get-boards


# -- Text in the rich-text format of the python rich library.
APIO_API_GET_BOARDS_HELP = """
The command 'apio api get-boards' exports apio boards information as a \
JSON document.

The optional flag '--timestamp' allows the caller to embed in the JSON \
document a known timestamp that allows to verify that the JSON document \
was indeed was generated by the same invocation.

Examples:[code]
  apio api get-boards                # Write to stdout
  apio api get-boards  -o apio.json  # Write to a file[/code]
"""


@click.command(
    name="get-boards",
    cls=ApioCommand,
    short_help="Retrieve boards information.",
    help=APIO_API_GET_BOARDS_HELP,
)
@timestamp_option
@output_option
@options.force_option_gen(help="Overwrite output file.")
def _get_boards_cli(
    # Options
    timestamp: str,
    output: str,
    force: bool,
):
    """Implements the 'apio apio get-boards' command."""

    # -- For now, the information is not in a project context. That may
    # -- change in the future.
    apio_ctx = ApioContext(scope=ApioContextScope.NO_PROJECT)

    # -- The top dict that we will emit as json.
    top_dict = {}

    # -- Append user timestamp if specified.
    if timestamp:
        top_dict["timestamp"] = timestamp

    # -- Generate the 'boards' section.
    section = {}
    for board_id, board_info in apio_ctx.boards.items():
        # -- The board output dict.
        board_dict = {}

        # -- Add board description
        board_dict["description"] = board_info.get("description", None)

        # -- Add board's fpga information.
        fpga_dict = {}
        fpga_id = board_info.get("fpga", None)
        fpga_info = apio_ctx.fpgas.get(fpga_id, {})
        fpga_dict["id"] = fpga_id
        fpga_dict["part-num"] = fpga_info.get("part-num", None)
        fpga_dict["arch"] = fpga_info.get("arch", None)
        fpga_dict["size"] = fpga_info.get("size", None)
        board_dict["fpga"] = fpga_dict

        # -- Add board's programmer information.
        programmer_dict = {}
        programmer_id = board_info.get("programmer", {}).get("type", None)
        programmer_dict["id"] = programmer_id
        board_dict["programmer"] = programmer_dict

        # -- Add the board to the boards dict.
        section[board_id] = board_dict

    top_dict["boards"] = section

    # -- Write out
    write_as_json_doc(top_dict, output, force)


# ------ apio api get-fpgas


# -- Text in the rich-text format of the python rich library.
APIO_API_GET_FPGAS_HELP = """
The command 'apio api get-fpgas' exports apio FPGAss information as a \
JSON document.

The optional flag '--timestamp' allows the caller to embed in the JSON \
document a known timestamp that allows to verify that the JSON document \
was indeed was generated by the same invocation.

Examples:[code]
  apio api get-fpgas                # Write to stdout
  apio api get-fpgas  -o apio.json  # Write to a file[/code]
"""


@click.command(
    name="get-fpgas",
    cls=ApioCommand,
    short_help="Retrieve FPGAs information.",
    help=APIO_API_GET_FPGAS_HELP,
)
@timestamp_option
@output_option
@options.force_option_gen(help="Overwrite output file.")
def _get_fpgas_cli(
    # Options
    timestamp: str,
    output: str,
    force: bool,
):
    """Implements the 'apio apio get-fpgas' command."""

    # -- For now, the information is not in a project context. That may
    # -- change in the future.
    apio_ctx = ApioContext(scope=ApioContextScope.NO_PROJECT)

    # -- The top dict that we will emit as json.
    top_dict = {}

    # -- Append user timestamp if specified.
    if timestamp:
        top_dict["timestamp"] = timestamp

    # -- Generate the 'fpgas' section.
    section = {}
    for fpga_id, fpga_info in apio_ctx.fpgas.items():
        # -- The fpga output dict.
        fpga_dict = {}

        fpga_dict["part-num"] = fpga_info.get("part-num", None)
        fpga_dict["arch"] = fpga_info.get("arch", None)
        fpga_dict["size"] = fpga_info.get("size", None)

        # -- Add the fpga to the fpgas dict.
        section[fpga_id] = fpga_dict

    top_dict["fpgas"] = section

    # -- Write out
    write_as_json_doc(top_dict, output, force)


# ------ apio api scan-devices


# -- Text in the rich-text format of the python rich library.
APIO_API_SCAN_DEVICES_HELP = """
The command 'apio api scan-devices' scans and report the available usb and \
serial devices.

The optional flag '--timestamp' allows the caller to embed in the JSON \
document a known timestamp that allows to verify that the JSON document \
was indeed was generated by the same invocation.

Examples:[code]
  apio api scan-devices                # Write to stdout
  apio api scan-devices  -o apio.json  # Write to a file[/code]
"""


@click.command(
    name="scan-devices",
    cls=ApioCommand,
    short_help="Scan and report available devices.",
    help=APIO_API_SCAN_DEVICES_HELP,
)
@timestamp_option
@output_option
@options.force_option_gen(help="Overwrite output file.")
def _scan_devices_cli(
    # Options
    timestamp: str,
    output: str,
    force: bool,
):
    """Implements the 'apio apio scan-devices' command."""

    # -- For now, the information is not in a project context. That may
    # -- change in the future.
    apio_ctx = ApioContext(scope=ApioContextScope.NO_PROJECT)

    # -- The top dict that we will emit as json.
    top_dict = {}

    # -- Append user timestamp if specified.
    if timestamp:
        top_dict["timestamp"] = timestamp

    # -- We need the packages for the 'libusb' backend.
    installer.install_missing_packages_on_the_fly(apio_ctx)

    usb_devices: List[UsbDevice] = usb_util.scan_usb_devices(apio_ctx)

    # -- Scan and report usb devices.
    section = []
    for device in usb_devices:
        dev = {}
        dev["vid"] = device.vendor_id
        dev["pid"] = device.product_id
        dev["bus"] = device.bus
        dev["device"] = device.device
        dev["manufacturer"] = device.manufacturer
        dev["product"] = device.product
        dev["serial-number"] = device.serial_number
        dev["device_type"] = device.device_type

        section.append(dev)

    top_dict["usb-devices"] = section

    # -- Scan and report serial devices.
    serial_devices: List[SerialDevice] = serial_util.scan_serial_devices()

    section = []
    for device in serial_devices:
        dev = {}
        dev["port"] = device.port
        dev["port-name"] = device.port_name
        dev["vendor-id"] = device.vendor_id
        dev["product-id"] = device.product_id
        dev["manufacturer"] = device.manufacturer
        dev["product"] = device.product
        dev["serial-number"] = device.serial_number
        dev["device-type"] = device.device_type

        section.append(dev)

    top_dict["serial-devices"] = section

    # -- Write out
    write_as_json_doc(top_dict, output, force)


# ------ apio apio

# -- Text in the rich-text format of the python rich library.
APIO_API_HELP = """
The command group 'apio api' contains subcommands that that are intended \
to be used by tools and programs such as icestudio, rather than being used \
directly by users.
"""

# -- We have only a single group with the title 'Subcommands'.
SUBGROUPS = [
    ApioSubgroup(
        "Subcommands",
        [
            _get_boards_cli,
            _get_fpgas_cli,
            _scan_devices_cli,
        ],
    )
]


@click.command(
    name="api",
    cls=ApioGroup,
    subgroups=SUBGROUPS,
    short_help="Apio programmatic interface.",
    help=APIO_API_HELP,
)
def cli():
    """Implements the 'apio apio' command group."""

    # pass
